\input pdfToolbox
\input preamble

\setlayout{horizontal margin=2cm, vertical margin=2cm}

{\setbox0=\hbox{\setfontandscale{bf}{25pt}Linear Reduction}
\centerline{
    \vbox{
        \copy0
        \smallskip
        \hbox to\wd0{\hfil Ari Feiglin and Noam Kaplinski}
    }
}}

\bigskip
\hbox to\hsize{\hfil\vbox{\hsize=.7\hsize
\leftskip=0pt plus 1fil \rightskip=\leftskip \parfillskip=\z@
\hrule
\kern5pt

In this paper we will define the concept of linear reduction in the context of syntax parsing.
We will progress through more and more complicated examples, beginning from the programming of a simple calculator until we ultimately have created an extensible programming language.

\kern5pt
\hrule
}\hfil}

\section*{Table of Contents}

\tableofcontents

\vfill\break

\setcounter{section}{-1}
\section{Notation}

\noindent ${\bb N}$ denotes the set of natural numbers, including $0$.

\smallskip
\noindent $\overline{\bb N}$ is defined to be ${\bb N}\cup\set\infty$.

\smallskip
\noindent $f\colon A\plongto B$ means that $f$ is a partial function from $A$ to $B$.

\smallskip
\noindent If ${\sf X}$ is a set and ${\sf x}$ is some symbol, then ${\sf X}_{\sf x}={\sf X}^{\sf x}={\sf X}\cup\set{{\sf x}}$.

\vfill\break

\section{Theoretical Background}

\subsection{Stateless Reduction}

The idea of linear reduction is simple: given a string $\xi$ the first character looks if it can bind with the second character to produce a new character, and the process repeats itself.
There is of course, nuance.
This nuance hides in the statement ``if it can bind'': we must define the rules for binding.

Let us define an {\it reducer} to be a tuple $(\Sigma,\beta,\pi)$ where $\Sigma$ is an alphabet; $\beta\colon\overline\Sigma\times\overline\Sigma\plongto\overline\Sigma$ is a partial function called the
{\it reduction function} where $\overline\Sigma=\Sigma\times\overline{\bb N}$; and $\pi$ is the {\it initial priority function}.
A {\it program} over an reducer is a string over $\overline\Sigma$.
We write a program like $\sigma^1_{i_1}\cdots\sigma^n_{i_n}$ instead of as pairs $(\sigma^1,i_1)\dots(\sigma^n,i_n)$.
In the character $\sigma_i$, we call $i$ the {\it priority} of $\sigma$.

Then the rules of reduction are as follows, meaning we define $\beta(\xi)$ for a program:
We do so in cases:
\benum
    \item If $\xi=\sigma_i$ then $\beta(\xi)=\sigma_0$.
    \item If $\xi=\sigma^1_i\sigma^2_j\xi'$ where $i\geq j$ and $\beta(\sigma^1_i,\sigma^2_j)=\sigma^3_k$ is defined then $\beta(\xi)=\sigma^3_k\xi'$.
    \item Otherwise, for $\xi=\sigma^1_i\sigma^2_j\xi'$, $\beta(\xi)=\sigma^1_i\beta(\sigma^2_j\xi')$.
\eenum

A string $\xi$ such that $\beta(\xi)=\xi$ is called {\it irreducible}.
Notice that it is possible for a string of length more than $1$ to be irreducible: for example if $\beta(\sigma^1,\sigma^2)$ is not defined then $\sigma^1_i\sigma^2_j$ is irreducible.
$$ \beta(\sigma_1\tau_2)\xvarrightarrow{(3)}\sigma_1\beta(\tau_2)\xvarrightarrow{(1)}\sigma_1\tau_2 $$
But such strings are not desired, since in the end we'd like a string to give us a value.
So an irreducible string which is not a single character is called {\it ill-written}, and a string which is not ill-written is {\it well-written}.

Now the initial priority function is $\pi\colon\Sigma\plongto\overline{\bb N}$ which gives characters their initial priority.
We can then canonically extend this to a function $\pi\colon\Sigma^*\plongto(\Sigma\times\overline{\bb N})^*$ defined by $\pi(\sigma^1\cdots\sigma^n)=\sigma^1_{\pi(\sigma^1)}\cdots\sigma^n_{\pi(\sigma^n)}$.
Then a $\beta$-reduction of a string $\xi\in\Sigma^*$ is taken to mean a $\beta$-reduction of $\pi(\xi)$.

Notice that once again we require that $\pi$ only be a partial function.
This is since that we don't always need every character in $\Sigma$ to have an initial priority; some symbols are only given their priority through the $\beta$-reduction of another pair of symbols.
So we now provide a new definition of a {\it program}, which is a string $\xi=\sigma^1\cdots\sigma^n\in\Sigma^*$ such that $\pi(\sigma^i)$ exists for all $1\leq i\leq n$.
We can only of course discuss the reductions of programs, as $\pi(\xi)$ is only defined if $\xi$ is a program.

\Example let $\Sigma={\bb N}\cup\set{+,\cdot}\cup\set{(n+),(n\cdot)}[n\in{\bb N}]$.
$\beta$ as follows:

\medskip
\centerline{
    \vtop{\ialign{\hfil$#$\hfil\tabskip=.25cm&\hfil$#$\hfil\cr
        \sigma^1_i,\sigma^2_j & \beta(\sigma^1_i,\sigma^2_j)\cr\noalign{\kern3pt\hrule\kern3pt}
        n,+ & (n+)\cr
        n,\cdot & (n\cdot)\cr
        (n+),m & n+m\cr
        (n\cdot),m & n\cdot m\cr
        (n\cdot),(m+) & (n\cdot m,+)\cr
        (n+),(m+) & (n+m,+)\cr
        (n\cdot),(m\cdot) & (n\cdot m,\cdot)\cr
    }}
}
\medskip
\noindent Where $n,m$ range over all values in ${\bb N}$.
Here $\beta(\sigma_i,\sigma_j)$'s priority is $j$.
We define the initial priorities
$$ \pi(n) = \infty,\quad \pi(+) = 1,\quad \pi(\cdot) = 2 $$

Now let us look at the string $1+2\cdot3+4;$.
Here,
$$ \eqalign{
    1_\infty+_12_\infty\cdot_23_\infty+_14_\infty &\longto (1+)_12_\infty\cdot_23_\infty+_14_\infty\cr
    &\longto (1+)_1(2\cdot)_23_\infty+_14_\infty\cr
    &\longto(1+)_1(2\cdot)_2(3+)_14_\infty\cr
    &\longto(1+)_1(6+)_14_\infty\cr
    &\longto(7+)_14_\infty\cr
    &\longto(7+)_14_0\cr
    &\longto(11)_0
} $$
So the rules for $\beta$ we supplied seem to be sufficient for computing arithmetic expressions following the order of operations.
\qedd

\Example We can also expand our language to include parentheses.
So our alphabet becomes $\Sigma={\bb N}\cup\set{+,\cdot,(,)}\cup\set{\uline{ n+},\uline{ n\cdot},\uline{ n)}}[n\in{\bb N}]$.
We distinguish between parentheses and bold parentheses for readability.
We extend $\beta$ as follows:

\medskip
\centerline{
    \vtop{\ialign{\hfil$#$\hfil\tabskip=.25cm&\hfil$#$\hfil\cr
        \sigma^1_i,\sigma^2_j & \beta(\sigma^1_i,\sigma^2_j)\cr\noalign{\kern3pt\hrule\kern3pt}
        n,+ & \uline{ n+}_j\cr
        n,\cdot & \uline{ n\cdot}_j\cr
        \uline{ n+},m & (n+m)_j\cr
        \uline{ n\cdot},m & (n\cdot m)_j\cr
        \uline{ n\cdot},\uline{ m+} & \uline{ n\cdot m,+}_j\cr
        \uline{ n+},\uline{ m+} & \uline{ n+m,+}_j\cr
        \uline{ n\cdot},\uline{ m\cdot} & \uline{ n\cdot m,\cdot}_j\cr
        n,) & \uline{ n)}_j\cr
        \uline{ n+},\uline{ m)} & \uline{ n+m)}_j\cr
        \uline{ n\cdot},\uline{ m)} & \uline{ n\cdot m)}_j\cr
        (,\uline{ n)} & n_i\cr
    }}
}
\medskip

\noindent $(n+m)_j$ means $n+m$ with a priority of $j$, not $\uline{ n+m}_j$.
And we define the initial priorities
$$ \pi(n) = \infty,\quad \pi(+) = 1,\quad \pi(\cdot) = 2,\quad \pi({(}) = \infty,\quad \pi({)}) = 0 $$
So for example reducing $2\cdot((1+2)\cdot2)+1$,
$$ \eqalign{
    2_\infty*_2{(_\infty}{(_\infty}1_\infty+_12_\infty{)_0}*_22_\infty{)_0}+_11_\infty &\longto \uline{2*}_2{(_\infty}{(_\infty}1_\infty+_12_\infty{)_0}*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}{(_\infty}\uline{1+}_12_\infty{)_0}*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}{(_\infty}\uline{1+}_1\uline{2)}_0*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}{(_\infty}\uline{3)}_0*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}3_\infty*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}\uline{3*}_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}\uline{3*}_2\uline{2)}_0+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}\uline{6)}_0+_11_\infty\cr
    &\longto \uline{2*}_26_\infty+_11_\infty\cr
    &\longto \uline{2*}_2\uline{6+}_11_\infty\cr
    &\longto \uline{12+}_11_\infty\cr
    &\longto \uline{12+}_11_0\cr
    &\longto 13_0\cr
} $$
\qedd

\subsection{Stateful Reduction}

Suppose we'd like to reduce a program with variables in it.
Then we cannot just use the previous definitions, as the actions of $\sigma$ (which is to be understood as the function $\beta(\sigma,\bullet)$) are determined before any reduction occurs.
We need a way to store the value of variables, a state.

This leads us to the following definition: let $\Sigma_P$ and $\Sigma_A$ be two disjoint sets of symbols: $\Sigma_P$ the set of {\it printable symbols} and $\Sigma_A$ the set of {\it abstract symbols}.
$\Sigma_P$ will generally be a set consisting of the string representations of abstract symbols, be it operators like $+$ and $\cdot$ or variable names.
$\Sigma_A$ are the actual objects which can ``execute something''.
Let us further define $\Sigma=\Sigma_P\cup\Sigma_A$.

Now a state is a mapping from printable symbols to strings.
So for example, if $x$ is a printable symbol a line like $\lett x=1$ should change the state so that $x$ maps to the abstract symbol representing $1$.

A {\it point state} is a partial function $s\colon\Sigma_P\plongto\Sigma_A$.
If $s_1,s_2$ are point states, define their composition to be a point state $s_1s_2$ such that
$$ s_1s_2(\sigma) = \cases{s_2(\sigma) & $\sigma\in{\rm dom}(s_2)$\cr s_1(\sigma) & $\sigma\in{\rm dom}(s_1)$} $$
A {\it state} is a sequence of point states: $\overline s=(s_1,\dots,s_n)$.
Let us define
$$ \State = \set{\Sigma_P\plongto\Sigma_A}^+ $$
the set of all states.

Let $\overline s=(s_1\cdots s_n)\in\State$ be a state, then define
\blist
    \item for $\sigma\in\Sigma_P$ we define $ s(\sigma)=s_1\cdots s_n(\sigma)$ (the composition of states),
    \item define $\pop\overline s=(s_1,\dots,s_{n-1})$,
    \item define $\push\overline s=(s_1,\dots,s_n,\varnothing)$ ($\varnothing$ is the empty state),
    \item if $s$ is a point state, $\overline ss=(s_1,\dots,s_{n-1},s_ns)$,
    \item if $s$ is a point state, $\overline s+s=(s_1,\dots,s_n,s)$ (so $\push\overline s=\overline s+\varnothing$).
\elist
\noindent So if we'd like to revert to a previous state, we simply pop from the current state.
And substituting the current state only alters the current (topmost) point state.

Now we begin with an initial $\beta$ function which is a partial function
$$ \beta\colon\overline\Sigma_A\times(\overline\Sigma\cup\set\epsilon)\times\State \plongto \overline\Sigma^*\times\State $$
Recall that $\overline\Sigma$ is $\Sigma\times{\bb N}$.
We will denote tuples in $X\times\State$ by $\gen{x,}[s]$ for $x\in X$ and $s\in\State$ for the sake of readability.
So we now wish to extend to a $\beta$ function
$$ \beta\colon\overline\Sigma^*\times\State \plongto \overline\Sigma^*\times\State $$
We do this as follows: given $\xi\in(\Sigma\times\overline{\bb N})^*$ and $s\in\State$ we define $\beta\gen{\xi}[s]$ as follows:
\benum
    \item if $\xi=\sigma_i\xi'$ for $\sigma\in\Sigma_P$ then $\beta\gen{\xi}[s]=\gen{s(\sigma)_i\xi'}[s]$,
    \item if $\xi=\sigma_i\xi'$ such that $\beta\gen{\sigma_i\epsilon}[s]=\gen{\xi''}[s']$ is defined then $\beta\gen{\xi}[s]=\gen{\xi''\xi'}[s']$,
    \item if $\xi=\sigma^1_i\sigma^2_j\xi'$ for $\sigma^1\in\Sigma_A$, $i\geq j$, such that $\beta\gen{\sigma^1_i\sigma^2_j}[s]=\gen{\xi''}[s']$ is defined, then
        $\beta\gen{\xi}[s]=\gen{\xi''\xi'}[s']$,
    \item otherwise for $\xi=\sigma^1_i\sigma^2_j\xi'$, if $\beta\gen{\sigma^2_j\xi'}[s]=\gen{\xi''}[s']$ then $\beta\gen{\xi}[s]=\gen{\sigma^1_i\xi''}[s']$.
\eenum
\noindent Notice that $\bf(2)$ cares not about the priority of $\sigma$, and neither if $\beta(\sigma_i,\tau_j)$ is defined for some $\tau\neq\epsilon$.

We also define the {\it initial priority function} to be a map $\pi\colon\Sigma_P\longto\overline{\bb N}$ (this is not a partial function: every printable symbol must be given a priority).
This is once again canonically extended to a function $\pi\colon\Sigma_P^*\longto(\Sigma_P\times\overline{\bb N})^*$.
And an {\it initial state} $s_0$ which is a point state.
The quintuple $(\Sigma_P,\Sigma_A,\beta,\pi,s_0)$ is called an {\it reducer}.
The reduction of a string $\xi\in S$ is the process of iteratively applying $\beta$ to $\gen{\pi(\xi)}[s_0]$.

\Example let
$$ \eqalign{
    \Sigma_P &= {\bb N}\cup\set{+,\cdot,=,;}\cup\set{{\tt let}}\cup\set{x^i}[i\in{\bb N}],\cr
    \Sigma_A &= {\bb N}\cup\set{(n+),(n\cdot)}[n\in{\bb N}]\cup\set{{\tt let}}\cup\set{({\tt let}x^i),({\tt let}x^i=)}[i\in{\bb N}]
} $$
where the natural numbers in $\Sigma_A$ are not the same as the natural numbers in $\Sigma_P$ since they must be disjoint, same for {\tt let}.
But they both essentially represent the same thing: $s_0$ maps $n\mapsto n$ for $n\in{\bb N}$ (the left-hand $n$ is in $\Sigma_p$, the right-hand $n$ is in $\Sigma_A$) and ${\tt let}\mapsto{\tt let}$.
All other printable symbols are mapped to $\epsilon$.

And similar to the previous example we define $\pi(n)=\infty$, $\pi(+)=1$, and $\pi(\cdot)=2$.
We extend this to $\pi(;)=0$, $\pi(=)=0$, $\pi({\tt let})=\infty$, and $\pi(x^i)=\infty$.

Let us take the same transitions as the example in the previous section for $n,(n+),(n\cdot)$ (we have to add the condition that the state doesnt change).
We further add the transitions
\medskip
\centerline{
    \vtop{\ialign{\hfil$#$\hfil\tabskip=.5cm&\hfil$#$\hfil\cr
        \gen{\sigma^1_i\sigma^2_j}[s] & \beta\gen{\sigma^1\sigma^2}[s]\cr\noalign{\kern3pt\hrule\kern3pt}
        \gen{\sigma;}[s] & \gen{\sigma_j}[s]\cr
        \gen{\lett x^i}[s] & \gen{(\lett x^i)_j}[s]\cr
        \gen{(\lett x^i)=}[s] & \gen{(\lett x^i=)_j}[s]\cr
        \gen{(\lett x^i=)\sigma}[s] & \gen{\epsilon}[{s[x^i\mapsto\sigma]}]\cr
}}}

\noindent In the final transition, $n\in\Sigma_A$.
Then for example (we will be skipping trivial reductions):
$$ \eqalign{
    \lett x^1=1+2;\ \lett x^2=2;\ x^1\cdot x^2; &\longto
    {\tt let}_\infty x^1_\infty=_01_\infty+_12_\infty;_0\ {\tt let}_\infty x^2_\infty =_0 2_\infty;_0\ x^1_\infty\cdot_2 x^2_\infty;_0\cr
    s_0\quad&\longto ({\tt let}x^1=)_01_\infty+_12_\infty;_0\ {\tt let}_\infty x^2_\infty =_0 2_\infty;_0\ x^1_\infty\cdot_2 x^2_\infty;_0\cr
    s_0\quad&\longto ({\tt let}x^1=)_03_0\ {\tt let}_\infty x^2_\infty =_0 2_\infty;_0\ x^1_\infty\cdot_2 x^2_\infty;_0\cr
    s_0[x^1\mapsto3]\quad&\longto {\tt let}_\infty x^2_\infty =_0 2_\infty;_0\ x^1_\infty\cdot_2 x^2_\infty;_0\cr
    s_0[x^1\mapsto3,\,x^2\mapsto2]\quad&\longto x^1_\infty\cdot_2 x^2_\infty;_0\cr
    s_0[x^1\mapsto3,\,x^2\mapsto2]\quad&\longto 3_\infty\cdot_2 x^2_\infty;_0\cr
    s_0[x^1\mapsto3,\,x^2\mapsto2]\quad&\longto (3\cdot)_2 x^2_\infty;_0\cr
    s_0[x^1\mapsto3,\,x^2\mapsto2]\quad&\longto (3\cdot)_2 2_\infty;_0\cr
    s_0[x^1\mapsto3,\,x^2\mapsto2]\quad&\longto 6_0\cr
} $$
\qedd

\subsection{Valued Reduction}

Notice that in the previous examples, many symbols had values, be it a number, a list, etc.
This leads us to the next variation of linear reduction: {\it valued} linear reduction.
Here we start with the sets: ${\cal U}$ the universe of values, $\Sigma_P$ the set of printable types, and $\Sigma_A$ the set of abstract types.

Here ${\cal U}$ is some arbitrary set, it will contain of all possible values (numbers, lists, strings, functions, etc.) in our program.
$\Sigma_P$ and $\Sigma_A$ are sets of symbols which we call {\it types}.

Let us further define $\Pi_A\coloneqq\Sigma_A\times\U$ to be the set of {\it abstract values}, $\Sigma\coloneqq\Sigma_P\cup\Sigma_A$ the set of types, and $\Pi=\Sigma_P\cup\Pi_A$ the set of {\it values}
(printable types are also values).
Elements of $\overline\Pi$ will be written like $\sigma_n(v)$ where $\sigma$ is the type, $n$ the priority, and $v$ the value (nothing for printable types).

Let us define a point-state, similar to stateful reductions, as partial functions from $\Sigma_P$ to $\Pi_A$.
Then a state is defined as a sequence of point-states similar to before.

In valued reduction, we abstract away some inputs to the initial beta-reducer in order to allow for easier implementation.
An initial beta-reducer is a partial function
$$ \hat\beta\colon \Sigma_A\times\Sigma_\epsilon\times{\rm State}\plongto\Sigma_A^\epsilon\times(\overline{\bb N}\times\overline{\bb N}\to\overline{\bb N})\times
({\cal U}\times{\cal U}\pto{\cal U}\times\Sigma_P^*\times{\rm State}) $$

We extend this to a derived $\beta$-reducer,
$$ \beta\colon\overline\Pi^*\times{\rm State}\plongto\overline\Pi^*\times{\rm State} $$
with the following rules: given an input $\gen{\xi}[s]$ its image is
\benum
    \item If $\xi=\sigma_n\xi'$ for $\sigma\in\Sigma_p$ then
        $$ \beta\gen{\xi}[s] = \gen{s(\sigma)_n\xi'}[s] . $$
    \item If $\xi=\sigma_i(v)\xi'$ and $\hat\beta(\sigma,\epsilon,s)=(\alpha,\rho,f)$ is defined, then if $f(v)=(w,\omega,s')$ and $\rho(i)=k$ then
        $$ \beta\gen{\xi}[s] = \gen{\alpha_k(w)\pi(\omega)\xi'}[s'] . $$
    \item If $\xi=\sigma_i(v)\tau_j(u)\xi'$ and $i\geq j$ and $\hat\beta(\sigma,\tau,s)=(\alpha,\rho,f)$ is defined, then if $f(v,u)=(w,\omega,s')$ and $\rho(i,j)=k$ then
        $$ \beta\gen{\xi}[s] = \gen{\alpha_k(w)\pi(\omega)\xi'}[s] . $$
    \item Otherwise, if $\xi=\sigma_i(v)\xi'$ and $\beta\gen{\xi'}[s]=\gen{\xi''}[s']$,
        $$ \beta\gen{\xi}[s] = \gen{\sigma_i(v)\xi''}[s'] . $$
\eenum

\subsubsection{States}

Similar to before, we define point-states as partial maps $\Sigma_P\plongto\Pi_A$.
And if $s_1,s_2$ are two point-states and $\sigma\in\Sigma_P$ then
$$ s_1s_2(\sigma) = \cases{s_2(\sigma) & $\sigma\in{\rm dom}s_2$\cr s_1(\sigma) & $\sigma\in{\rm dom}s_1$} $$
We will denote finite point states as $[\sigma_1\mapsto\varkappa_1,\dots,\sigma_n\mapsto\varkappa_n]$, and this denotes the point-state which maps $\sigma_i$ to $\varkappa_i$.
Then we define a state to be a sequence of point-states.
For a state $\bar s=(s_1,\dots,s_n)$, let us define
\benum
    \item $\bar s+s=(s_1,\dots,s_n,s)$
    \item $\pop\bar s=(s_1,\dots,s_{n-1})$
    \item $\bar ss=(s_1,\dots,s_ns)$
    \item $\bar s(\sigma)=s_1\cdots s_n(\sigma)$ for $\sigma\in\Sigma_P$
\eenum
Furthermore, if $\sigma\in\Sigma_P$ and $\varkappa\in\Pi_A$ let us define $\bar s\{\sigma\mapsto\varkappa\}$ as $(s_1,\dots,s_i[\sigma\mapsto\varkappa],\dots,s_n)$ where $i$ is the maximum index such that
$\sigma\in{\rm dom}s_i$.

\subsubsection{The Initial Beta Reducer}

We will now construct the initial $\beta$-reducer for our programming language.
By convention, {\astyle abstract types} will be colored red.

\noindent{\bf End:}
We add an abstract type $\eend$ with the initial reduction rule
$$ {\astyle\sigma}\ \eend\ s \longto \sigma\ {\sf zero}\ (u\to u) $$
where ${\sf zero}$ is the constant zero map.

\noindent{\bf Arithmetic:}
For each abstract type $\asig$ we define the ``compound'' abstract type $\asig\op$ with rules:
\blist
    \item $\asig\ \op\ s \longto \asig\op\ \snd\ \bigl(v,f\to(v,f),\epsilon,s\bigr)$
    \item $\asig\op\ \asig\op\ s\longto \asig\op\ \snd\ \bigl((v,f),(u,g)\to(f(v,u),g),\epsilon,s\bigr)$
    \item $\asig\op\ \asig\ s\longto \asig\ \snd\ \bigl((v,f),u\longto f(v,u),\epsilon,s\bigr)$
\elist
Where $\fst,\snd$ are the first and second projection maps respectively.
Notice that here things of the form $(n,f)$ etc. are {\it values} (which are just arbitrary).
We further define the abstract types $\num$ and $\str$.
These abstract types we have just defined allow for basic arithmetic:
$$ \eqalign{
    \num_\infty(1) \op_1(+) \num_\infty(2) \op_2(\cdot) \num_\infty(3)\eend_0 &\longto \num\op_1(1,+)\num_\infty(2)\op_2(\cdot)\num_\infty(3)\eend_0\cr
    &\longto \num\op_1(1,+)\num\op_2(2,\cdot)\num_\infty(3)\eend_0\cr
    &\longto \num\op_1(1,+)\num\op_2(2,\cdot)\num_0(3)\cr
    &\longto \num\op_1(1,+)\num_0(6)\cr
    &\longto \num_0(7)
} $$

We further define $\lparen$ and $\rparen$, as well as the compound type $\asig\rparen$ as follows:
\blist
    \item $\asig\ \rparen\ s\longto \asig\rparen\ \snd\ \bigl(n\to n,\epsilon,s\bigr)$
    \item $\asig\op\ \asig\rparen\ s\longto \asig\rparen\ \snd\ \bigl((f,n),m\to f(n,m),\epsilon,s\bigr)$
    \item $\lparen\ \asig\rparen\ s\longto \asig\ \fst\ \bigl(n\to n,\epsilon,s\bigr)$
\elist

\noindent{\bf Lists:}
We add $\lbrack$, $\rbrack$, the compound type $\asig\lbrack$, the compound type $\asig\list$, $\period$, and $\index$:
\blist
    \item $\lbrack\ {\astyle\sigma}\ s\longto \asig\lbrack\ \snd\ \bigl(u\to(u),\epsilon,s\bigr)$ for ${\astyle\sigma}\neq\lbrack,\rbrack$
    \item $\asig\lbrack\ {\astyle\sigma}\ s\longto \asig\lbrack\ \snd\ \bigl(\ell,u\to(\ell,\sigma(u)),\epsilon,s\bigr)$ for ${\astyle\sigma}\neq\lbrack,\rbrack$
    \item $\asig\lbrack\ \rbrack\ s\longto \asig\list\ {\sf infty}\ \bigl(\ell\to\ell,\epsilon,s\bigr)$
    \item $\period\ \num\ s\longto \index\ {\sf zero}\ \bigl(n\to n,\epsilon,s\bigr)$
    \item $\asig\list\ \index\ s\longto \asig\ \fst\ \bigl((v_0,\dots,v_n),i\to v_i,\epsilon,s\bigr)$
\elist
So for example $[1+2;2;]$ will be converted to (really this is misleading, since the printable tokens aren't converted into abstract tokens before parsing, but rather during it.
The following example is just to give some intuition)
\lmultlines{
    \lbrack_0 \num_\infty(1) \op_1(+) \num_\infty(2)\eend_0 \num_\infty(2)\eend_0 \rbrack_0\cr
    &\longto \lbrack_0 \num\op_1(1,+) \num_\infty(2)\eend_0 \num_\infty(2)\eend_0\rbrack_0\cr
    &\longto \lbrack_0 \num\op_1(1,+) \num_0(2) \num_\infty(2) \eend_0\rbrack_0\cr
    &\longto \lbrack_0 \num_0(3) \num_\infty(2) \eend_0\rbrack_0\cr
    &\longto \num\lbrack_0(3) \num_\infty(2)\eend_0\rbrack_0\cr
    &\longto \num\lbrack_0(3) \num_0(2)\rbrack_0\cr
    &\longto \num\lbrack_0(3,2)\rbrack_0\cr
    &\longto \num\list_\infty(3,2)\cr
}
And
$$ \eqalign{
    \num\list_\infty(0,1,2,3,4)\period_\infty\num_\infty(2) &\longto \num\list_\infty(0,1,2,3,4)\index_0(2)\cr
    &\longto\num_\infty(2)
} $$

\noindent{\bf Variables:}
We add $\lett$, $\leteq$, $\sett$, $\seteq$, and $\equal$,
\blist
    \item $\lett\ x\ s\longto \lett\ \snd\ \bigl(\to (x,\varnothing),\epsilon,s\bigr)$
    \item $\lett\ \index\ s\longto \lett\ \fst\ \bigl((x,\ell),n\to(x,(\ell,n)),\epsilon,s\bigr)$
    \item $\lett\ \equal\ s\longto \leteq\ \snd\ \bigl((x,\ell)\to (x,\ell),\epsilon,s\bigr)$
    \item $\leteq\ {\astyle\sigma}\ s\longto \epsilon\ \fst\ \bigl((x,\ell),v\to \epsilon,\epsilon,s'\bigr)$ where $s'$ is $s[x\mapsto\sigma(v)]$ if $\ell=\varnothing$ otherwise if $\ell=(i_1,\dots,i_n)$
        then let $\varkappa$ be $s(x)$ where $s(x).i_1\dots i_n$ is set to be $v$, then $s'=s[x\mapsto\varkappa]$.
    \item $\sett\ x\ s\longto \sett\ \snd\ \bigl(\to (x,\varnothing),\epsilon,s\bigr)$
    \item $\sett\ \index\ s\longto \sett\ \fst\ \bigl((x,\ell),n\to(x,(\ell,n)),\epsilon,s\bigr)$
    \item $\sett\ \equal\ s\longto \seteq\ \snd\ \bigl((x,\ell)\to(x,\ell),\epsilon,s\bigr)$
    \item $\seteq\ {\astyle\sigma}\ s\longto \epsilon\ \fst\ \bigl((x,\ell),v\to \epsilon,\epsilon,s'\bigr)$ where $s'$ is $s[x\mapsto v]$ if $\ell$ is empty and otherwise if $\ell=(i_1,\dots,i_n)$ then
        let $\varkappa$ be $s(x)$ where $s(x).i_1.i_2\dots i_n$ is swapped with $v$, and $s'$ is $s\{x\mapsto\varkappa\}$.
\elist
For example
$$ \eqalign{
    \lett_\infty x_\infty \equal_0 \num_\infty(2)\eend_0 & \longto \lett_\infty(x) \equal_0 \num_\infty(2)\eend_0\cr
    &\longto \leteq_0(x) \num_\infty(2)\eend_0\cr
    &\longto \leteq_0(x) \num_0(2)\cr
    &\longto \epsilon\cr
} $$
and the state will have changed to $s[x\mapsto\num(2)]$.
And if $s$ is a state where $x\mapsto\num\list(0,1)$ then
$$ \eqalign{
    \lett_\infty x_\infty \period_\infty \num_\infty(1) \equal_0 \num_\infty(2) &\longto \lett_\infty(x) \period_\infty \num_\infty(1) \equal_0 \num_\infty(2)\eend_0\cr
    &\longto \lett_\infty(x) \index_0(1) \equal_0 \num_\infty(2)\eend_0\cr
    &\longto \lett_\infty(x,(1)) \equal_0 \num_\infty(2)\eend_0\cr
    &\longto \leteq_0(x,(1)) \num_\infty(2)\eend_0\cr
    &\longto \leteq_0(x,(1)) \num_0(2)\cr
    &\longto \epsilon\cr
} $$
and the state will have changed to $s[x\mapsto\num\list(0,2)]$.

\noindent{\bf Scoping:}
We add $\lbrace$ and $\rbrace$:
\blist
    \item $\lbrace\ \epsilon\ s\longto \epsilon\ \fst\ \bigl(\to \epsilon,\epsilon,s+\varnothing\bigr)$
    \item $\rbrace\ \epsilon\ s\longto \epsilon\ \fst\ \bigl(\to \epsilon,\epsilon,\pop s\bigr)$
\elist
This highlights another difference between $\lett$ and $\sett$: $\lett$ creates a new variable in the current scope, and $\sett$ alters an existing variable in the scope for which it is defined.
This is like doing {\tt int x = 0} vs {\tt x = 0} in C.

\bye

